<?xml version="1.0" encoding="utf-8"?>
<search>
  
    <entry>
      <title><![CDATA[AFNetworking3.0/NSURLSession的理解]]></title>
      <url>/ios/2017/07/19/two-AFNetworking/</url>
      <content type="text"><![CDATA[  很多时候，AFNetworking都是目前iOS开发者网络库中的不二选择。Github上2W+的star数足见其流行程度。而从iOS7.0开始，苹果推出了新的网络库继承者NSURLSession后，AFNetworking也毫不犹豫地加入了对其的支持。3.0+更加只是提供了NSURLSession的支持。AFNetworking常用的写法我们使用AFNetworking的时候，可能会有很多的朋友都会采用以下的写法：AFHTTPSessionManager *sessionManager = [AFHTTPSessionManager manager];    sessionManager.requestSerializer     = [AFHTTPRequestSerializer serializer];    sessionManager.responseSerializer    = [AFHTTPResponseSerializer serializer];    [sessionManager GET:urlString             parameters:parameters               progress:progressBlock                success:successHandler                failure:failureHandler];大概可以描述一下这个过程，每次开启一个网络请求时，首先新建一个AFHTTPSessionManager，然后将相关的requestSerializer和reponseSerializer赋值；最后发起相应的GET/POST等请求。而如果是直接采用NSURLSession来请求网络呢，我们则经常会采用以下的写法：NSURLSession *session =  [NSURLSession     sessionWithConfiguration:    [NSURLSessionConfiguration defaultSessionConfiguration]     delegate:nil      delegateQueue:[NSOperationQueue mainQueue]];            NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request      completionHandler:completionHandler];          [dataTask resume];这个过程其实和上面的基本一致。新建一个Session，然后新建task，激活task，完成网络请求。那么现在问题来了。为什么每次都需要新建一个SessionManager/Session？如果在多个Task请求的情况下，如果采取一个共享的SessionManager/Session是否可行？如果可行，与之前每次新建SessionManager/Session相比，孰优孰劣？这篇文章的主要目的本篇文章会告诉您：  为什么要使用NSURLSession而不是NSURLConnection  为什么要用共享的SessionManager/Session，而不是每次都启动一个新的为什么要选择NSURLSessionNSURLSession在iOS7.0时被Apple提出后，虽然Apple一直对其良好的API设计大力推广，然而其能够达到的效果，似乎一直都和NSURLConnection不相伯仲。特别是在网络的Dependecy依赖处理上，由于AFNetworking优秀的架构设计，NSURLSession甚至还不如NSURLConnection好用。那么，有什么理由切换到NSURLSession？ 2015年的WWDC似乎告诉了我们答案。HTTP /2, 2015年5月RFC 7540正式发表的下一代HTTP协议，是1999年来HTTP 1.1发布后的首个更新。相对于前一个版本，HTTP /2以快著称。对相同图片、相同服务器的下载，在不同协议下所需的时间：  对于HTTP 1.1与HTTP 2加载时间对照（这是我查了HTTP官方解释得到的）   HTTP 1.1 load time：9.63s    HTTP 2  load time：2.32s这里我们并不打算展开HTTP /2的原理，有兴趣的同学可以Google之。根据2015的WWDC Session711，我们知道iOS9+，NSURLSession开始正式支持HTTP /2，也就意味着你的网络连接速度也可以有如上图那样的提升。更人性化更优秀的API设计，HTTP /2的支持，这是否能成为你使用NSURLSession的理由？至少它们成为了说服我的理由。为什么要尽量共享Session，而不是每次新建Session在回答这个问题以前，我们先来聊聊网络的通讯协议。我们也都知道，HTTP协议是基于TCP协议的。所以在每次的HTTP请求之前，客户端和服务器端，都先需要经过TCP连接的三次握手，即每次请求之前，网络的数据都已经在客户端和服务器端之间来回了三次。如下图：关于HTTP的三次握手，我在另一篇博文有介绍，可自行查阅相关了解。事实上，苹果的文档中，还对一个服务器最高的TCP并发有相应的描述：HTTPMaximumConnectionsPerHost  PropertyThe maximum number of simultaneous connections to make to a given host.DeclarationSWIFT    var HTTPMaximumConnectionsPerHost: IntOBJECTIVE-C    @property NSInteger HTTPMaximumConnectionsPerHostDiscussionThis property determines the maximum number of simultaneous connections made to each host by tasks within sessions based on this configuration.This limit is per session, so if you use multiple sessions, your app as a whole may exceed this limit. Additionally, depending on your connection to the Internet, a session may use a lower limit than the one you specify.The default value is 6 in OS X, or 4 in iOS.AvailabilityAvailable in iOS 7.0 and later.我们可以看到，默认配置下，iOS对于同一个IP服务器的并发最大为4，OS X为6。而如果你没有使用共享的Session，则可能会超过这个数。因此，如果能用共享的Session，还是用共享的吧。有些许的网络加速，也是一件不错的事情.]]></content>
      <categories>
        
          <category> iOS </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[HTTP通信及HTTP通信过程简介]]></title>
      <url>/ios/2016/02/16/first-test/</url>
      <content type="text"><![CDATA[HTTP(HyperText Transfer Protocol)是一套计算机通过网络进行通信的规则。HTTP(HyperText Transfer Protocol)是一套计算机通过网络进行通信的规则。计算机专家设计出HTTP，使HTTP客户（如Web浏览器）能够从HTTP服务器(Web服务器)请求信息和服务，HTTP目前协议的版本是1.1.HTTP是一种无状态的协议，无状态是指Web浏览器和Web服务器之间不需要建立持久的连接，这意味着当一个客户端向服务器端发出请求，然后Web服务器返回响应(response)，连接就被关闭了，在服务器端不保留连接的有关信息.HTTP遵循请求(Request)/应答(Response)模型。Web浏览器向Web服务器发送请求，Web服务器处理请求并返回适当的应答。所有HTTP连接都被构造成一套请求和应答HTTP使用内容类型是指Web服务器向Web浏览器返回的文件都有与之相关的类型。所有这些类型在MIME　Internet邮件协议上模型化，即Web服务器告诉Web浏览器该文件所具有的种类，是HTML文档、GIF格式图像、声音文件还是独立的应用程序。大多数Web浏览器都拥有一系列的可配置的辅助应用程序，它们告诉浏览器应该如何处理Web服务器发送过来的各种内容类型。HTTP与web之间的7个步骤HTTP通信机制是在一次完整的HTTP通信过程中，Web浏览器与Web服务器之间将完成下列7个步骤：建立TCP连接在HTTP工作开始之前，Web浏览器首先要通过网络与Web服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。HTTP是比TCP更高层次的应用层协议，根据规则，只有低层协议建立之后才能，才能进行更层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80Web浏览器向Web服务器发送请求命令一旦建立了TCP连接，Web浏览器就会向Web服务器发送请求命令例如：GET/sample/hello.jsp HTTP/1.1Web浏览器发送请求头信息浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。Web服务器应答客户机向服务器发出请求后，服务器会客户机回送应答，HTTP/1.1 200 OK应答的第一部分是协议的版本号和应答状态码Web服务器发送应答头信息正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。Web服务器向浏览器发送数据Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据Web服务器关闭TCP连接一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码Connection:keep-aliveTCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽HTTP请求格式当浏览器向Web服务器发出请求时，它向服务器传递了一个数据块，也就是请求信息，HTTP请求信息由3部分组成：1.请求方法URI协议/版本2.请求头(Request Header)3.请求正文下面是一个HTTP请求的例子：GET/sample.jspHTTP/1.1Accept:image/gif.image/jpeg,*/*Accept-Language:zh-cnConnection:Keep-AliveHost:localhostUser-Agent:Mozila/4.0(compatible;MSIE5.01;Window NT5.0)Accept-Encoding:gzip,deflateusername=jinqiao&amp;password=1234（1） 请求方法URI协议/版本请求的第一行是“方法URL议/版本”：GET/sample.jsp HTTP/1.1以上代码中“GET”代表请求方法，“/sample.jsp”表示URI，“HTTP/1.1代表协议和协议的版本。根据HTTP标准，HTTP请求可以使用多种请求方法。例如：HTTP1.1支持7种请求方法：GET、POST、HEAD、OPTIONS、PUT、DELETE和TARCE。在Internet应用中，最常用的方法是GET和POST。URL完整地指定了要访问的网络资源，通常只要给出相对于服务器的根目录的相对目录即可，因此总是以“/”开头，最后，协议版本声明了通信过程中使用HTTP的版本。（2）　请求头(Request Header)请求头包含许多有关的客户端环境和请求正文的有用信息。例如，请求头可以声明浏览器所用的语言，请求正文的长度等。Accept:image/gif.image/jpeg./Accept-Language:zh-cnConnection:Keep-AliveHost:localhostUser-Agent:Mozila/4.0(compatible:MSIE5.01:Windows NT5.0)Accept-Encoding:gzip,deflate.（3）　请求正文请求头和请求正文之间是一个空行，这个行非常重要，它表示请求头已经结束，接下来的是请求正文。请求正文中可以包含客户提交的查询字符串信息：username=jinqiao&amp;password=1234在以上的例子的HTTP请求中，请求的正文只有一行内容。当然，在实际应用中，HTTP请求正文可以包含更多的内容。HTTP请求方法我这里只讨论GET方法与POST方法GET方法GET方法是默认的HTTP请求方法，我们日常用GET方法来提交表单数据，然而用GET方法提交的表单数据只经过了简单的编码，同时它将作为URL的一部分向Web服务器发送，因此，如果使用GET方法来提交表单数据就存在着安全隐患上。例如Http://127.0.0.1/login.jsp?Name=zhangshi&amp;Age=30&amp;Submit=%cc%E+%BD%BB从上面的URL请求中，很容易就可以辩认出表单提交的内容。（？之后的内容）另外由于GET方法提交的数据是作为URL请求的一部分所以提交的数据量不能太大POST方法POST方法是GET方法的一个替代方法，它主要是向Web服务器提交表单数据，尤其是大批量的数据。POST方法克服了GET方法的一些缺点。通过POST方法提交表单数据时，数据不是作为URL请求的一部分而是作为标准数据传送给Web服务器，这就克服了GET方法中的信息无法保密和数据量太小的缺点。因此，出于安全的考虑以及对用户隐私的尊重，通常表单提交时采用POST方法。　　从编程的角度来讲，如果用户通过GET方法提交数据，则数据存放在QUERY＿STRING环境变量中，而POST方法提交的数据则可以从标准输入流中获取。HTTP应答与HTTP请求相似，HTTP响应也由3个部分构成，分别是：1.协议状态版本代码描述2.响应头(Response Header)3.响应正文下面是一个HTTP响应的例子：HTTP/1.1 200 OKServer:Apache Tomcat/5.0.12Date:Mon,6Oct2003 13:23:42 GMTContent-Length:112&lt;html&gt;&lt;head&gt;&lt;title&gt;HTTP响应示例&lt;title&gt;&lt;/head&gt;&lt;body&gt;Hello HTTP!&lt;/body&gt;&lt;/html&gt;协议状态代码描述HTTP响应的第一行类似于HTTP请求的第一行，它表示通信所用的协议是HTTP1.1服务器已经成功的处理了客户端发出的请求（200表示成功）:HTTP/1.1 200 OK响应头(Response Header)响应头也和请求头一样包含许多有用的信息，例如服务器类型、日期时间、内容类型和长度等：　　 Server:Apache Tomcat/5.0.12Date:Mon,6Oct2003 13:13:33 GMTContent-Type:text/htmlLast-Moified:Mon,6 Oct 2003 13:23:42 GMTContent-Length:112响应正文响应正文就是服务器返回的HTML页面：　　&lt;html&gt;&lt;head&gt;&lt;title&gt;HTTP响应示例&lt;title&gt;&lt;/head&gt;&lt;body&gt;Hello HTTP!&lt;/body&gt;&lt;/html&gt;响应头和正文之间也必须用空行分隔。　　HTTP应答码　　　HTTP应答码也称为状态码，它反映了Web服务器处理HTTP请求状态。HTTP应答码由3位数字构成，其中首位数字定义了应答码的类型：　　　1XX－信息类(Information),表示收到Web浏览器请求，正在进一步的处理中　　　2XX－成功类（Successful）,表示用户请求被正确接收，理解和处理例如：200 OK3XX-重定向类(Redirection),表示请求没有成功，客户必须采取进一步的动作。4XX-客户端错误(Client Error)，表示客户端提交的请求有错误 例如：404 NOTFound，意味着请求中所引用的文档不存在。5XX-服务器错误(Server Error)表示服务器不能完成对请求的处理：如 500对于我们Web开发人员来说掌握HTTP应答码有助于提高Web应用程序调试的效率和准确性。安全连接Web应用最常见的用途之一是电子商务，可以利用Web服务器端程序使人们能够网络购物，需要指出一点是，缺省情况下，通过Internet发送信息是不安全的，如果某人碰巧截获了你发给朋友的一则消息，他就能打开它，假想在里面有你的信用卡号码，这会有多么糟糕，幸运的是，很多Web服务器以及Web浏览器都有创立安全连接的能力，这样它们就可以安全的通信了。通过Internet提供安全连接最常见的标准是安全套接层(Secure Sockets layer,SSl)协议。SSL协议是一个应用层协议(和HTTP一样)，用于安全方式在Web上交换数据，SSL使用公开密钥编码系统。从本质讲，这意味着业务中每一方都拥有一个公开的和一个私有的密钥。当一方使用另一方公开密钥进行编码时，只有拥有匹配密钥的人才能对其解码。简单来讲，公开密钥编码提供了一种用于在两方之间交换数据的安全方法，SSL连接建立之后，客户和服务器都交换公开密钥，并在进行业务联系之前进行验证，一旦双方的密钥都通过验证，就可以安全地交换数据。HTTP协议状态码的含义"100 " : Continue "101 " : witching Protocols "200 " : OK "201 " : Created "202 " : Accepted "203 " : Non-Authoritative Information "204 " : No Content "205 " : Reset Content "206 " : Partial Content "300 " : Multiple Choices "301 " : Moved Permanently "302 " : Found "303 " : See Other "304 " : Not Modified "305 " : Use Proxy "307 " : Temporary Redirect "400 " : Bad Request "401 " : Unauthorized "402 " : Payment Required "403 " : Forbidden "404 " : Not Found "405 " : Method Not Allowed "406 " : Not Acceptable "407 " : Proxy Authentication Required "408 " : Request Time-out "409 " : Conflict "410 " : Gone "411 " : Length Required "412 " : Precondition Failed "413 " : Request Entity Too Large "414 " : Request-URI Too Large "415 " : Unsupported Media Type "416 " : Requested range not satisfiable "417 " : Expectation Failed "500 " : Internal Server Error "501 " : Not Implemented "502 " : Bad Gateway "503 " : Service Unavailable "504 " : Gateway Time-out "505 " : HTTP Version not supported]]></content>
      <categories>
        
          <category> iOS </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Next Theme Tutorial]]></title>
      <url>/tutorial/2015/07/20/next-tutorial/</url>
      <content type="text"><![CDATA[  NexT is a high quality elegant Jekyll theme ported from Hexo Next. It is crafted from scratch, with love.Live PreviewScreenshots      Desktop        Sidebar    Sidebar (Post details page)  MobileInstallationCheck whether you have Ruby 2.1.0 or higher installed:ruby --versionInstall Bundler:gem install bundlerClone Jacman theme:git clone https://github.com/Simpleyyt/jekyll-theme-next.gitcd jekyll-theme-nextInstall Jekyll and other dependencies from the GitHub Pages gem:bundle installRun your Jekyll site locally:bundle exec jekyll serverMore Details：Setting up your GitHub Pages site locally with JekyllFeaturesMultiple languages support, including: English / Russian / French / German / Simplified Chinese / Traditional Chinese.Default language is English.language: en# language: zh-Hans# language: fr-FR# language: zh-hk# language: zh-tw# language: ru# language: deSet language field as following in site _config.yml to change to Chinese.language: zh-HansComment support.NexT has native support for DuoShuo and Disqus comment systems.Add the following snippets to your _config.yml:duoshuo:  enable: true  shortname: your-duoshuo-shortnameORdisqus_shortname: your-disqus-shortnameSocial MediaNexT can automatically add links to your Social Media accounts:social:  GitHub: your-github-url  Twitter: your-twitter-url  Weibo: your-weibo-url  DouBan: your-douban-url  ZhiHu: your-zhihu-urlFeed link.  Show a feed link.Set rss field in theme’s _config.yml, as the following value:  rss: false will totally disable feed link.      rss:   use sites’ feed link. This is the default option.    Follow the installation instruction in the plugin’s README. After the configuration is done for this plugin, the feed link is ready too.    rss: http://your-feed-url set specific feed link.Up to 5 code highlight themes built-in.NexT uses Tomorrow Theme with 5 themes for you to choose from.Next use normal by default. Have a preview about normal and night:Head over to Tomorrow Theme for more details.ConfigurationNexT comes with few configurations.# Menu configuration.menu:  home: /  archives: /archives# Faviconfavicon: /favicon.ico# Avatar (put the image into next/source/images/)# can be any image format supported by web browsers (JPEG,PNG,GIF,SVG,..)avatar: /default_avatar.png# Code highlight theme# available: normal | night | night eighties | night blue | night brighthighlight_theme: normal# Fancybox for image galleryfancybox: true# Specify the date when the site was setupsince: 2013Browser support]]></content>
      <categories>
        
          <category> tutorial </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
</search>
